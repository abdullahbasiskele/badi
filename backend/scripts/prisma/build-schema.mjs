#!/usr/bin/env node
import { promises as fs } from 'fs';
import path from 'path';
import process from 'process';

const prismaDir = path.resolve(process.cwd(), 'prisma');
const basePath = path.join(prismaDir, 'schema.base.prisma');
const outputPath = path.join(prismaDir, 'schema.prisma');

const sections = [
  { label: 'Enums', dir: path.join(prismaDir, 'enums') },
  { label: 'Tables', dir: path.join(prismaDir, 'tables') },
];

async function readSection(dir) {
  try {
    const entries = await fs.readdir(dir);
    const prismaFiles = entries.filter(name => name.endsWith('.prisma')).sort();
    const contents = [];
    for (const file of prismaFiles) {
      const fullPath = path.join(dir, file);
      const data = await fs.readFile(fullPath, 'utf8');
      const header = '// --- ' + file + ' ---';
      contents.push(header + '\n' + data.trim() + '\n');
    }
    return contents.join('\n');
  } catch (err) {
    if (err.code === 'ENOENT') {
      return '';
    }
    throw err;
  }
}

async function build() {
  const base = await fs.readFile(basePath, 'utf8');
  const parts = [base.trimEnd(), '// Auto-generated by scripts/prisma/build-schema.mjs'];

  for (const section of sections) {
    const body = await readSection(section.dir);
    if (body) {
      const title = '// ===== ' + section.label.toUpperCase() + ' =====';
      parts.push(title, body.trimEnd());
    }
  }

  const output = parts.join('\n\n') + '\n';
  await fs.writeFile(outputPath, output, { encoding: 'utf8' });
}

build().catch(err => {
  console.error('[build-schema] Failed to generate Prisma schema:', err);
  process.exit(1);
});
